<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Reflections</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>ðŸ›  Project Reflections</h1>
    </header>

    <section id="project-overview">
        <h2>ðŸ“Œ Project Overview</h2>
        <p>The Smart Parking Management System represents the practical application of algorithmic concepts learned in the course.</p>
    </section>

    <section id="technical-implementation">
        <h2>ðŸ”§ Technical Implementation</h2>
        <ul>
            <li>Applied graph algorithms for optimal parking space allocation</li>
            <li>Implemented a real-time updating system</li>
            <li>Created efficient data structures for parking management</li>
        </ul>
    </section>

    <section id="learning-outcomes">
        <h2>ðŸŽ“ Learning Outcomes</h2>
        <p>This project helped me understand the real-world application of algorithms and the importance of efficient system design.</p>
    </section>

    <section id="reflections-on-design">
        <h2>ðŸ’¡ Reflections on Problem-Solving and Algorithm Design</h2>

        <article>
            <h3>1.How do you determine the most efficient approach when solving a complex problem?</h3>
            <p>To determine the most efficient approach:</p>
            <ul>
                <li><strong>Analyze the Problem:</strong> Break it down to understand its constraints, input size, and expected output.</li>
                <li><strong>Evaluate Algorithmic Options:</strong> Compare possible solutions based on their time and space complexities.</li>
                <li><strong>Consider Constraints:</strong> Prioritize time efficiency over space when real-time processing is required.</li>
                <li><strong>Test Feasibility:</strong> Use sample inputs to ensure the algorithm handles edge cases effectively.</li>
            </ul>
        </article>

        <article>
            <h3>2.What criteria do you use to evaluate the effectiveness of a solution?</h3>
            <ul>
                <li><strong>Efficiency:</strong> Does the solution run within acceptable time and space limits?</li>
                <li><strong>Scalability:</strong> Can it handle large datasets or increased input sizes?</li>
                <li><strong>Robustness:</strong> Does it work correctly across all edge cases?</li>
                <li><strong>Maintainability:</strong> Is the code readable and easy to modify for future requirements?</li>
                <li><strong>Simplicity:</strong> Avoid unnecessary complexity while meeting requirements.</li>
            </ul>
        </article>

        <article>
            <h3>3.Reflect on a situation where you need to balance multiple conflicting constraints in a design. What approach did you take?</h3>
            <p><strong>Example:</strong> Designing an algorithm for a parking management system.</p>
            <ul>
                <li><strong>Conflicting Constraints:</strong> Real-time responsiveness (time efficiency) vs. accurate predictions based on large datasets (space efficiency).</li>
                <li><strong>Approach:</strong>
                    
                        <li>Used greedy algorithms for quick decisions on immediate scheduling.</li>
                        <li>Employed dynamic programming for long-term optimizations, running in the background.</li>
                        <li>Cached intermediate results to reduce redundant calculations.</li>
                    
                </li>
            </ul>
        </article>

        <article>
            <h3>4.How do you decide when to prioritize simplicity over optimization in a solution?</h3>
            <ul>
                <li><strong>Problem Context:</strong> Simplicity is prioritized for well-defined, small-scale, or rapid prototyping scenarios.</li>
                <li><strong>Resource Constraints:</strong> Limited time or computational resources favor simple solutions.</li>
                <li><strong>Future Scope:</strong> Simplicity ensures maintainability for evolving solutions.</li>
                <li><strong>Example:</strong> For a classroom project, I prioritize simplicity to ensure the solution is understandable and meets learning objectives.</li>
            </ul>
        </article>

        <article>
            <h3>5.Reflect on how breaking down a problem into smaller components can help you approach it more effectively.</h3>
            <p><strong>Example:</strong> Implementing a dynamic programming solution for the Knapsack problem.</p>
            <ul>
                <li>Divided the problem into subproblems (smaller weight capacities and items).</li>
                <li>Solved each subproblem iteratively and used the results to build the final solution.</li>
                <li><strong>Benefits:</strong> Simplifies debugging, improves clarity, and helps identify patterns in the problem.</li>
            </ul>
        </article>

        <article>
            <h3>6.Reflect on the trade-offs while choosing between different approaches to solve a problem.</h3>
            <p><strong>Example:</strong> Choosing between Merge Sort and Quick Sort.</p>
            <ul>
                <li><strong>Merge Sort:</strong> Stable and predictable (O(n log n)) but uses more space (O(n)).</li>
                <li><strong>Quick Sort:</strong> Faster on average but has a worst-case time complexity of O(nÂ²).</li>
                <li><strong>Decision:</strong> For large datasets where stability matters, I choose Merge Sort; for in-memory operations with small datasets, Quick Sort is preferable.</li>
            </ul>
        </article>

        <article>
            <h3>7.How do you identify and address potential limitations or weaknesses in a proposed solution?</h3>
            <ul>
                <li><strong>Stress Testing:</strong> Run the solution on edge cases and large datasets to identify weaknesses.</li>
                <li><strong>Performance Profiling:</strong> Measure time and space usage to detect bottlenecks.</li>
                <li><strong>Feedback:</strong> Seek peer reviews to catch overlooked issues.</li>
                <li><strong>Refinement:</strong> Optimize code sections with the highest impact, such as reducing redundant operations.</li>
            </ul>
        </article>

        <article>
            <h3>8.How do you decide when to innovate versus relying on tried-and-tested solutions?</h3>
            <ul>
                <li><strong>Problem Novelty:</strong> Start with tried-and-tested methods for problems that align closely with existing solutions.</li>
                <li><strong>Opportunity for Improvement:</strong> Innovate when existing methods fall short in efficiency or scalability.</li>
                <li><strong>Example:</strong> For navigating the nearest parking spot, I integrated the current location of the user into Dijkstra's algorithm.</li>
            </ul>
        </article>

    </section>

</body>
</html>
